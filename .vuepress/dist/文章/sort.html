<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>手撕排序算法(上) |  </title>
    <meta name="generator" content="VuePress 1.5.1">
    <link rel="icon" href="/head.jpg">
    <script>
              var _hmt = _hmt || [];
              (function() {
                  var hm = document.createElement("script");
                  hm.src = "https://hm.baidu.com/hm.js?850788452cf34b7fc456bd7e8a437504";
                  var s = document.getElementsByTagName("script")[0];
                  s.parentNode.insertBefore(hm, s);
              })();
            </script>
    <meta name="description" content=" ">
    <link rel="preload" href="/assets/css/0.styles.634e714d.css" as="style"><link rel="preload" href="/assets/js/app.ca55f1f3.js" as="script"><link rel="preload" href="/assets/js/2.3d422307.js" as="script"><link rel="preload" href="/assets/js/20.20844c9b.js" as="script"><link rel="prefetch" href="/assets/js/10.d44dd5fc.js"><link rel="prefetch" href="/assets/js/11.1d7f4788.js"><link rel="prefetch" href="/assets/js/12.d9ac2996.js"><link rel="prefetch" href="/assets/js/13.97123d3f.js"><link rel="prefetch" href="/assets/js/14.6306d5c7.js"><link rel="prefetch" href="/assets/js/15.a01a39aa.js"><link rel="prefetch" href="/assets/js/16.8535a798.js"><link rel="prefetch" href="/assets/js/17.0c02993b.js"><link rel="prefetch" href="/assets/js/18.467c7743.js"><link rel="prefetch" href="/assets/js/19.03927c16.js"><link rel="prefetch" href="/assets/js/21.ba52c2a4.js"><link rel="prefetch" href="/assets/js/3.60c0e456.js"><link rel="prefetch" href="/assets/js/4.7609c85e.js"><link rel="prefetch" href="/assets/js/5.94c6c031.js"><link rel="prefetch" href="/assets/js/6.59ee72a0.js"><link rel="prefetch" href="/assets/js/7.b0488f60.js"><link rel="prefetch" href="/assets/js/8.d968c73b.js"><link rel="prefetch" href="/assets/js/9.8ef21330.js">
    <link rel="stylesheet" href="/assets/css/0.styles.634e714d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name"> </span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/index.html" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/作品/" class="nav-link">
  作品
</a></div><div class="nav-item"><a href="/文章/" class="nav-link">
  文章
</a></div><div class="nav-item"><a href="/随笔/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="https://github.com/cc456xie" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/index.html" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/作品/" class="nav-link">
  作品
</a></div><div class="nav-item"><a href="/文章/" class="nav-link">
  文章
</a></div><div class="nav-item"><a href="/随笔/" class="nav-link">
  随笔
</a></div><div class="nav-item"><a href="https://github.com/cc456xie" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>文章</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/文章/HTTP.html" class="sidebar-link">HTTP初探</a></li><li><a href="/%E6%96%87%E7%AB%A0/" aria-current="page" class="sidebar-link">我对前端行业的思考</a></li><li><a href="/文章/bfc.html" class="sidebar-link">BFC探究</a></li><li><a href="/文章/functionProgram.html" class="sidebar-link">函数式编程从入门到出家</a></li><li><a href="/文章/promise.html" class="sidebar-link">promise解析</a></li><li><a href="/文章/serverless.html" class="sidebar-link">serverless-大前端的思考</a></li><li><a href="/文章/sort.html" class="active sidebar-link">手撕排序算法(上)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/文章/sort.html#冒泡排序" class="sidebar-link">冒泡排序</a></li><li class="sidebar-sub-header"><a href="/文章/sort.html#选择排序" class="sidebar-link">选择排序</a></li><li class="sidebar-sub-header"><a href="/文章/sort.html#堆排序" class="sidebar-link">堆排序</a></li><li class="sidebar-sub-header"><a href="/文章/sort.html#插入排序" class="sidebar-link">插入排序</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="手撕排序算法-上"><a href="#手撕排序算法-上" class="header-anchor">#</a> 手撕排序算法(上)</h1> <h2 id="冒泡排序"><a href="#冒泡排序" class="header-anchor">#</a> 冒泡排序</h2> <h3 id="介绍"><a href="#介绍" class="header-anchor">#</a> 介绍</h3> <p><strong>冒泡排序</strong>是最经典的排序算法之一，由于排序过程中元素会慢慢上浮，像冒泡一样，由此得名冒泡排序。</p> <h3 id="原理"><a href="#原理" class="header-anchor">#</a> 原理</h3> <p>1,升序排序情况下，由数组头部开始，相邻两个元素依次比较，若前一个元素大于后一个，则两元素交换位置</p> <p>2,再数组中所有元素都进行一次比较后，则完成了一次循环，此时最大的元素已经冒泡到了数组末端</p> <p>3,再重复对除被冒泡到末端以外的元素进行1,2的操作，直到所有元素都完成了冒泡</p> <p>4,排序结束</p> <h3 id="特点"><a href="#特点" class="header-anchor">#</a> 特点</h3> <p>冒泡排序是一种<strong>原地算法</strong>，即不需要开辟额外空间，在数组内部即可完成排序。</p> <p>冒泡排序是<strong>稳定</strong>的排序方法</p> <p>冒泡排序的时间复杂度为<strong>O(n^2)</strong></p> <h3 id="实现"><a href="#实现" class="header-anchor">#</a> 实现</h3> <div class="language- extra-class"><pre class="language-text"><code>
			var bublesort = function(arr){
				for(let i=arr.length - 1;i &gt;= 0;i--)
				{
					for(let j=0;j &lt; i;j++)
					{
						if(arr[j] &gt; arr[j+1])
						{
							let tmp = arr[j]
							arr[j] = arr[j+1]
							arr[j+1] = tmp
						}
					}
				}
				return arr
			}


</code></pre></div><h3 id="优化"><a href="#优化" class="header-anchor">#</a> 优化</h3> <p>1, 若该数组本来有序，则不需要进入循环，此时时间复杂度应为 <strong>O(1)</strong>。但是貌似js的循环机制的问题，我测最小的时间复杂度也有O(n)，目前还不知道原因，等有机会再好好研究研究。</p> <p>可以初始化一个bool值，当一次循环结束bool依然为true时，即可判断数组已经有序，直接返回</p> <div class="language- extra-class"><pre class="language-text"><code>			var bublesort = function(arr){
				for(let i=arr.length - 1;i &gt;= 0;i--)
				{
					let isSorted = true
					for(let j=0;j &lt; i;j++)
					{
						if(arr[j] &gt; arr[j+1])
						{
							let tmp = arr[j]
							arr[j] = arr[j+1]
							arr[j+1] = tmp
							isSorted = false
						}
					}
					if(isSorted)
					{
						return arr
					}
				}
			}
</code></pre></div><p>2,若数组后半部分本来就有序，则可以通过记录最后一次交换位置的索引值来优化循环的长度</p> <div class="language- extra-class"><pre class="language-text"><code>			var bublesort = function(arr){
				for(let i=arr.length - 1;i &gt;= 0;i--)
				{
	                let lastIndex = -1
					for(let j=0;j &lt; i;j++)
					{
						if(arr[j] &gt; arr[j+1])
						{
							lastIndex = j+1
							let tmp = arr[j]
							arr[j] = arr[j+1]
							arr[j+1] = tmp	
						}
					}
					if(lastIndex&lt;0)
					return arr
					i = lastIndex
				}
				return arr
			}

</code></pre></div><h2 id="选择排序"><a href="#选择排序" class="header-anchor">#</a> 选择排序</h2> <h3 id="介绍-2"><a href="#介绍-2" class="header-anchor">#</a> 介绍</h3> <p><strong>选择排序</strong>是一种简单直观的排序算法,</p> <h3 id="特点-2"><a href="#特点-2" class="header-anchor">#</a> 特点</h3> <p>1,选择排序是一种<strong>不稳定</strong>的排序算法</p> <p>2，选择排序的时间复杂度为O(n^2)</p> <h3 id="原理-2"><a href="#原理-2" class="header-anchor">#</a> 原理</h3> <p>1，对待排序数列进行一次循环，找出其中最大的元素</p> <p>2，将最大元素与末尾的元素进行交换</p> <p>3，对除开末尾的剩余元素再次进行1，2操作</p> <p>4，重复以上操作，直到所有元素都有序</p> <h3 id="实现-2"><a href="#实现-2" class="header-anchor">#</a> 实现</h3> <div class="language- extra-class"><pre class="language-text"><code>			var selectionSort = function(arr){
				for(let i=arr.length - 1;i &gt;= 0;i--)
				{
			        let maxIndex = 0
					for(let j=1;j &lt;= i;j++)
					{
						if(arr[j] &gt;= arr[maxIndex])
						{
							maxIndex = j
							
						}
					}
					let tmp = arr[i]
					arr[i] = arr[maxIndex]
					arr[maxIndex] = tmp	
				}
				return arr
			}
			
</code></pre></div><h2 id="堆排序"><a href="#堆排序" class="header-anchor">#</a> 堆排序</h2> <h3 id="介绍-3"><a href="#介绍-3" class="header-anchor">#</a> 介绍</h3> <p><strong>堆排序</strong>可以看作是一种特殊的<strong>选择排序</strong>。借助于堆这个数据结构的特性，对于大顶堆，堆顶总是最大的元素，堆底总是最小的元素。只需要将堆顶的根节点和末尾元素进行交换，再将剩下的元素重新构建一个堆，重复交换操作，就可完成排序。</p> <h3 id="特点-3"><a href="#特点-3" class="header-anchor">#</a> 特点</h3> <p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p> <p>堆是一种<strong>完全二叉树</strong>，大顶堆：每个结点的值都大于或等于其左右孩子结点的值。小顶堆：每个结点的值都小于或等于其左右孩子结点的值</p> <h3 id="步骤"><a href="#步骤" class="header-anchor">#</a> 步骤</h3> <p>1，将一个无序数组构建成一个大顶堆</p> <p>2，将堆顶元素与末尾元素交换，使末尾元素最大</p> <p>3，继续调整堆，让剩下元素满足堆的定义</p> <p>4，将新的堆的头尾元素交换，此时得到第二大元素</p> <p>5，以此类推，直到整个序列有序</p> <h3 id="实现-3"><a href="#实现-3" class="header-anchor">#</a> 实现</h3> <div class="language- extra-class"><pre class="language-text"><code>			// 建堆函数
			var heapify =(arr,root,n) =&gt; {												
				let left = root*2+1,right = root*2+2;
				let max = root				
				if(root &gt;= n)
				return
            
			if(left &lt; n &amp;&amp; arr[left] &gt; arr[max])
			{
				max = left
			}
			if(right &lt; n &amp;&amp; arr[right] &gt; arr[max])
			{
			    max = right
	       }
		   
		   if(max !== root)
		   {
			   swap(arr,root,max)
			   // 若交换元素，则递归判断该元素的子节点
			   heapify(arr,max,n)
		   }             
			}
			// 交换元素
			var swap = (arr,root,max) =&gt; {
				let tmp = arr[root]
				arr[root] = arr[max]
				arr[max] = tmp
			}
			// 初始化堆
			var buildheap = (arr,length) =&gt; {
				for(let i=Math.floor(length/2);i&gt;=0;i--)
				{
					heapify(arr,i,length)
				}
			}
			// 堆排序
			var heapsort = (arr,length) =&gt; {
				buildheap(arr,length)
				for(let i = length-1;i&gt;0;i--)
				{
					swap(arr,i,0)
					 heapify(arr,0,i)
				}
			}
			heapsort(arr,arr.length)
</code></pre></div><h2 id="插入排序"><a href="#插入排序" class="header-anchor">#</a> 插入排序</h2> <h3 id="介绍-4"><a href="#介绍-4" class="header-anchor">#</a> 介绍</h3> <p>插入排序是一种<strong>稳定</strong>排序算法，类似于打扑克牌中摸牌组牌的原理。从数组中一次取出一个数和前面的比较，将其插入合适的位置。</p> <h3 id="原理-3"><a href="#原理-3" class="header-anchor">#</a> 原理</h3> <p>1，从数组的第二个数开始，与前面的数进行比较，若小于前面的数，则两数交换位置</p> <p>2，对交换位置后较小的数，再与前一位进行比较，若小于，则交换位置</p> <p>3，重复以上步骤，直到遇到大于或等于前一位的数，则停止</p> <p>4，再取出第三个数（即第一步的下一个数），重复以上步骤，直到数列有序</p> <h3 id="实现-4"><a href="#实现-4" class="header-anchor">#</a> 实现</h3> <div class="language- extra-class"><pre class="language-text"><code>			var insertSort = (arr) =&gt; {
				for(let begin=1;begin&lt;arr.length;begin++)
				{
					let count = begin
					while( count &gt; 0 &amp;&amp; arr[count] &lt; arr[count-1])
					{
						let tmp = arr[count]
						arr[count] = arr[count-1]
						arr[count-1] = tmp
						count--
					}
				}
				return arr
			}
</code></pre></div><h3 id="优化-2"><a href="#优化-2" class="header-anchor">#</a> 优化</h3> <p>对于每一次比对，若是一个<code>逆序对</code>，都需要完成一次交换操作，若该数列逆序对很多，则交换操作也很多，加大了性能损耗。</p> <p>可以通过<strong>挪动</strong>的方式优化，即每次比对不需要交换，直接将元素后移，将需要插入的元素保存起来，最后直接插入最后一个比较的位置上即可。</p> <div class="language- extra-class"><pre class="language-text"><code>			var insertSort = (arr) =&gt; {
				for(let begin=1;begin&lt;arr.length;begin++)
				{
					let count = begin
					let tmp = arr[begin]
					while( count &gt; 0 &amp;&amp; tmp &lt; arr[count-1])
					{
						arr[count] = arr[count-1]
						count--
					}
					arr[count] = tmp
				}
				return arr
			}
</code></pre></div><blockquote><p>虽然都要经过两次循环，但是用赋值操作代替了交换操作，会更加优化一些。</p></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/文章/serverless.html" class="prev">
        serverless-大前端的思考
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ca55f1f3.js" defer></script><script src="/assets/js/2.3d422307.js" defer></script><script src="/assets/js/20.20844c9b.js" defer></script>
  </body>
</html>
